<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC Video Chat</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for a better look and feel */
        body {
            font-family: 'Inter', sans-serif;
        }
        .video-container {
            position: relative;
            width: 100%;
            padding-top: 56.25%; /* 16:9 Aspect Ratio */
            background-color: #1a202c; /* dark gray */
        }
        video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* Mirror effect */
        }
        #localVideo {
            width: 25%;
            height: 25%;
            position: absolute;
            bottom: 1rem;
            right: 1rem;
            border: 2px solid #4a5568; /* gray */
            z-index: 10;
        }
        .control-button {
            transition: all 0.2s ease-in-out;
        }
        .control-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        #chat-messages {
            scroll-behavior: smooth;
        }
    </style>
    <!-- Google Fonts for a nicer typography -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-900 text-white flex items-center justify-center min-h-screen">

    <div id="app-container" class="w-full max-w-6xl mx-auto p-4">

        <!-- Entry Screen: Create or Join Room -->
        <div id="entryScreen" class="text-center bg-gray-800 p-8 rounded-lg shadow-xl">
            <h1 class="text-4xl font-bold mb-6">WebRTC Video Chat</h1>
            <p class="text-gray-400 mb-8">Create a room and share the code, or join a room with a code.</p>
            <div class="flex flex-col md:flex-row items-center justify-center gap-4">
                <button id="createRoomBtn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-lg w-full md:w-auto control-button">Create Room</button>
                <div class="flex items-center w-full md:w-auto">
                    <input type="text" id="joinCodeInput" placeholder="Enter Join Code" class="bg-gray-700 text-white border-2 border-gray-600 rounded-l-lg p-3 w-full focus:outline-none focus:border-indigo-500">
                    <button id="joinRoomBtn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-r-lg control-button">Join Room</button>
                </div>
            </div>
            <div id="errorMessage" class="text-red-400 mt-4 h-6"></div>
        </div>

        <!-- Video Call Screen -->
        <div id="callScreen" class="hidden">
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-4">
                <!-- Video Area -->
                <div class="lg:col-span-2 bg-gray-800 p-4 rounded-lg shadow-xl">
                    <div class="video-container rounded-lg overflow-hidden">
                        <video id="remoteVideo" autoplay playsinline></video>
                        <video id="localVideo" autoplay playsinline muted></video>
                    </div>
                    <div class="flex justify-center items-center mt-4 space-x-4">
                        <button id="muteBtn" class="bg-gray-700 hover:bg-gray-600 text-white font-bold p-3 rounded-full control-button">
                            <!-- SVG icon for Mute -->
                            <svg id="muteIcon" class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z"></path></svg>
                            <!-- SVG icon for Unmute -->
                            <svg id="unmuteIcon" class="w-6 h-6 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z" clip-rule="evenodd"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2"></path></svg>
                        </button>
                        <button id="endCallBtn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-lg control-button">End Call</button>
                    </div>
                     <div class="text-center mt-4">
                        <p class="text-gray-400">Room Code: <span id="roomCodeDisplay" class="font-mono bg-gray-700 p-1 rounded"></span></p>
                    </div>
                </div>

                <!-- Chat Area -->
                <div class="lg:col-span-1 bg-gray-800 p-4 rounded-lg shadow-xl flex flex-col h-[80vh]">
                    <h2 class="text-2xl font-bold mb-4 border-b border-gray-700 pb-2">Chat</h2>
                    <div id="chat-messages" class="flex-grow overflow-y-auto mb-4 space-y-4 pr-2">
                        <!-- Chat messages will be appended here -->
                    </div>
                    <form id="chat-form" class="flex items-center">
                        <input type="text" id="chat-input" placeholder="Type a message..." class="bg-gray-700 text-white border-2 border-gray-600 rounded-l-lg p-3 w-full focus:outline-none focus:border-indigo-500">
                        <button type="submit" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-r-lg control-button">Send</button>
                    </form>
                </div>
            </div>
        </div>
    </div>

    <script>
        // DOM Elements
        const entryScreen = document.getElementById('entryScreen');
        const callScreen = document.getElementById('callScreen');
        const createRoomBtn = document.getElementById('createRoomBtn');
        const joinRoomBtn = document.getElementById('joinRoomBtn');
        const joinCodeInput = document.getElementById('joinCodeInput');
        const errorMessage = document.getElementById('errorMessage');
        
        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');
        const muteBtn = document.getElementById('muteBtn');
        const muteIcon = document.getElementById('muteIcon');
        const unmuteIcon = document.getElementById('unmuteIcon');
        const endCallBtn = document.getElementById('endCallBtn');
        const roomCodeDisplay = document.getElementById('roomCodeDisplay');

        const chatForm = document.getElementById('chat-form');
        const chatInput = document.getElementById('chat-input');
        const chatMessages = document.getElementById('chat-messages');

        // WebSocket and WebRTC variables
        let ws;
        let peerConnection;
        let localStream;
        let remoteStream;
        let dataChannel;
        let currentJoinCode = null;
        let isMuted = false;

        // STUN servers for NAT traversal
        const stunServers = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' }
            ]
        };

        // Initialize WebSocket connection
        function initWebSocket() {
            // Use wss:// for secure connections (like on Glitch or Heroku)
            const wsUrl =
                window.location.protocol === 'https:' ? 'wss://' + window.location.host :
                window.location.protocol === 'http:' ? 'ws://' + window.location.host :
                'ws://localhost:8080';
            ws = new WebSocket(wsUrl);

            ws.onopen = () => console.log('WebSocket connection established.');
            ws.onmessage = handleWebSocketMessage;
            ws.onclose = () => {
                console.log('WebSocket connection closed.');
                showError('Connection to server lost. Please refresh.');
            };
            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                showError('Could not connect to the signaling server.');
            };
        }

        // Handle incoming WebSocket messages from the signaling server
        async function handleWebSocketMessage(message) {
            const data = JSON.parse(message.data);
            console.log('Received message:', data.type);

            switch (data.type) {
                case 'room_created':
                    currentJoinCode = data.joinCode;
                    roomCodeDisplay.textContent = currentJoinCode;
                    showCallScreen();
                    break;
                case 'offer':
                    await createPeerConnection();
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
                    const answer = await peerConnection.createAnswer();
                    await peerConnection.setLocalDescription(answer);
                    ws.send(JSON.stringify({ type: 'answer', joinCode: currentJoinCode, answer: answer }));
                    showCallScreen();
                    break;
                case 'answer':
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
                    break;
                case 'ice_candidate':
                    if (data.candidate) {
                        await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
                    }
                    break;
                case 'peer_disconnected':
                    showError('The other user has disconnected.');
                    resetCall();
                    break;
                case 'error':
                    showError(data.message);
                    break;
            }
        }

        // Start the process of creating a room
        createRoomBtn.onclick = async () => {
            await startMedia();
            if (!localStream) return;
            
            const joinCode = generateJoinCode();
            currentJoinCode = joinCode;
            
            await createPeerConnection();
            
            // Create Data Channel for chat
            dataChannel = peerConnection.createDataChannel('chat');
            setupDataChannel(dataChannel);

            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);

            ws.send(JSON.stringify({ type: 'create_room', joinCode: joinCode, offer: offer }));
        };

        // Start the process of joining a room
        joinRoomBtn.onclick = async () => {
            const joinCode = joinCodeInput.value.trim();
            if (!joinCode) {
                showError('Please enter a join code.');
                return;
            }
            await startMedia();
            if (!localStream) return;
            
            currentJoinCode = joinCode;
            roomCodeDisplay.textContent = currentJoinCode;
            ws.send(JSON.stringify({ type: 'join_room', joinCode: joinCode }));
        };
        
        // Get user media (camera and microphone)
        async function startMedia() {
            try {
                localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                localVideo.srcObject = localStream;
            } catch (error) {
                console.error('Error accessing media devices.', error);
                if (error.name === 'NotReadableError') {
                    showError('Camera or microphone is already in use by another application.');
                } else {
                    showError('Could not access camera/microphone. Please check permissions.');
                }
                localStream = null;
            }
        }

        // Create and configure the RTCPeerConnection
        async function createPeerConnection() {
            peerConnection = new RTCPeerConnection(stunServers);

            // Add local stream tracks to the connection
            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
            });

            // Handle incoming remote tracks
            peerConnection.ontrack = event => {
                if (!remoteStream) {
                    remoteStream = new MediaStream();
                }
                remoteStream.addTrack(event.track);
                remoteVideo.srcObject = remoteStream;
            };

            // Handle ICE candidate generation
            peerConnection.onicecandidate = event => {
                if (event.candidate) {
                    ws.send(JSON.stringify({ type: 'ice_candidate', joinCode: currentJoinCode, candidate: event.candidate }));
                }
            };

            // Handle incoming data channel for joiner
            peerConnection.ondatachannel = event => {
                dataChannel = event.channel;
                setupDataChannel(dataChannel);
            };
        }
        
        // Setup listeners for the RTCDataChannel
        function setupDataChannel(channel) {
            channel.onopen = () => console.log('Data channel is open!');
            channel.onclose = () => console.log('Data channel is closed.');
            channel.onmessage = event => {
                appendChatMessage(JSON.parse(event.data), 'remote');
            };
        }

        // Chat functionality
        chatForm.onsubmit = (e) => {
            e.preventDefault();
            const message = chatInput.value.trim();
            if (message && dataChannel && dataChannel.readyState === 'open') {
                const messageData = { sender: 'You', text: message };
                dataChannel.send(JSON.stringify(messageData));
                appendChatMessage(messageData, 'local');
                chatInput.value = '';
            }
        };

        function appendChatMessage(data, type) {
            const messageElement = document.createElement('div');
            messageElement.classList.add('p-3', 'rounded-lg', 'max-w-xs');
            
            if (type === 'local') {
                messageElement.classList.add('bg-indigo-600', 'self-end', 'ml-auto');
                messageElement.innerHTML = `<p class="text-white">${data.text}</p>`;
            } else {
                messageElement.classList.add('bg-gray-600', 'self-start', 'mr-auto');
                messageElement.innerHTML = `<p class="text-white">${data.text}</p>`;
            }
            chatMessages.appendChild(messageElement);
            chatMessages.scrollTop = chatMessages.scrollHeight; // Auto-scroll
        }

        // Control button handlers
        muteBtn.onclick = () => {
            isMuted = !isMuted;
            localStream.getAudioTracks()[0].enabled = !isMuted;
            muteIcon.classList.toggle('hidden', isMuted);
            unmuteIcon.classList.toggle('hidden', !isMuted);
            muteBtn.classList.toggle('bg-indigo-600', isMuted);
        };

        endCallBtn.onclick = () => {
            resetCall();
            window.location.reload(); // Simple way to reset state
        };
        
        // Utility functions
        function generateJoinCode() {
            return Math.random().toString(36).substring(2, 8).toUpperCase();
        }

        function showError(message) {
            errorMessage.textContent = message;
            setTimeout(() => errorMessage.textContent = '', 3000);
        }

        function showCallScreen() {
            entryScreen.classList.add('hidden');
            callScreen.classList.remove('hidden');
        }

        function resetCall() {
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.close();
            }
            entryScreen.classList.remove('hidden');
            callScreen.classList.add('hidden');
        }

        // Initialize the application
        initWebSocket();
    </script>
</body>
</html>
